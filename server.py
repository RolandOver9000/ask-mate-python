from flask import Flask, render_template, request, redirect, url_for
import connection
import data_manager

app = Flask(__name__)


@app.route("/")
@app.route("/list")
def route_list():
    questions = connection.get_csv_data()

    # If user presses the 'Sort' button,
    # function gets the keyword arguments from the query string in the URL
    # generated by the the get request.
    if request.args:
        order_by, order_direction = request.args.get('sorting').split('.')
    else:
        order_by, order_direction = 'submission_time', 'desc'

    sorted_questions = data_manager.get_sorted_questions(questions, order_by, order_direction)

    return render_template('list.html', sorted_questions=sorted_questions,
                           selected_sorting=order_by, selected_order=order_direction)


@app.route("/add-question", methods=['GET', 'POST'])
def route_add():

    if request.method == 'GET':
        return render_template('add-question.html', question_data={})

    user_inputs_for_question = request.form.to_dict()
    new_id = data_manager.get_new_id_for("question")
    data_manager.write_new_question_data_to_file(user_inputs_for_question, new_id)

    return redirect(url_for('display_question_and_answers', question_id=new_id))


@app.route('/question/<question_id>', methods=["GET", "POST"])
def display_question_and_answers(question_id):
    # get question and answer(s)
    question_data = connection.get_csv_data(data_id=question_id)
    answers_data = connection.get_csv_data(answer=True, data_id=question_id)

    # get ids of all questions as a list for 'next/previous question' links
    question_ids = connection.get_list_of_ids()

    # updates the votes
    if request.method == "POST":
        # get the data of the clicked button in list (3 elements)
        form_data = list(request.form["vote"].split(","))
        vote_option = form_data[0]
        message_id = form_data[1]
        message_type = form_data[2]
        data_manager.handle_votes(vote_option, message_id, message_type)
        # after handle, refresh the page with the updated data
        question_data = connection.get_csv_data(data_id=question_id)
        answers_data = connection.get_csv_data(answer=True, data_id=question_id)
        return render_template('question.html', question=question_data, answers=answers_data, question_ids=question_ids)
    else:
        data_manager.increment_view_number(question_data)
        return render_template('question.html', question=question_data, answers=answers_data, question_ids=question_ids)


@app.route('/question/<question_id>/edit', methods=['GET', 'POST'])
def route_edit(question_id):
    question_data = connection.get_csv_data(data_id=question_id)

    if request.method == 'GET':
        return render_template('add-question.html', question_data=question_data)

    user_inputs_for_question = request.form.to_dict()
    data_manager.update_question_data_in_file(question_id, user_inputs_for_question)

    return redirect(url_for('display_question_and_answers', question_id=question_id))


@app.route("/question/<question_id>/new-answer", methods=["GET", "POST"])
def post_an_answer(question_id):
    if request.method == "POST":
        user_inputs_for_answer = request.form.to_dict()
        data_manager.write_new_answer_data_to_file(user_inputs_for_answer, question_id)
        return redirect(url_for('display_question_and_answers', question_id=question_id))
    else:
        question = connection.get_csv_data(data_id=question_id)
        return render_template("new_answer.html", question=question)


@app.route('/question/<question_id>/delete')
def route_delete(question_id):

    data_manager.delete_question_from_file(question_id)
    data_manager.update_id_pair_in_file()

    return redirect(url_for('route_list'))


if __name__ == '__main__':
    app.run(debug=True)
